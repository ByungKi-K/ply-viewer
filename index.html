<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Three.js + PLYLoader + OrbitControls</title>
  <style>
    /* 화면 전체를 캔버스로 사용 */
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="module">
    /*
      1) Three.js (ES Module 버전) - CDN
      2) OrbitControls (ES Module 버전) - CDN
      3) PLYLoader (ES Module 버전) - CDN
    */
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js";
    import { PLYLoader } from "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/PLYLoader.js";

    let scene, camera, renderer, controls;

    init();
    animate();

    function init() {
      // 씬(Scene)
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      // 카메라(Camera)
      camera = new THREE.PerspectiveCamera(
        75,                                // 시야각(FOV)
        window.innerWidth / window.innerHeight,  // 종횡비
        0.1,  // near
        1000  // far
      );
      camera.position.set(0, 0, 2);

      // 렌더러(Renderer)
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // 컨트롤(OrbitControls)
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.target.set(0, 0, 0);

      // 조명(Light)
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(5, 10, 7.5);
      scene.add(dirLight);

      const ambLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambLight);

      // .ply 파일 로드
      const loader = new PLYLoader();
      loader.load(
        "./sample.ply", // 실제 .ply 파일 이름/경로에 맞게 수정
        (geometry) => {
          // 법선 계산
          geometry.computeVertexNormals();

          // 점(Points) 클라우드로 렌더링
          const material = new THREE.PointsMaterial({
            size: 0.01,
            vertexColors: true,  // .ply에 색상 정보가 있다면 표시됨
          });
          const points = new THREE.Points(geometry, material);
          scene.add(points);

          /* 
          // 메시(Mesh)로 보고 싶다면 이렇게 교체:
          const meshMaterial = new THREE.MeshLambertMaterial({ vertexColors: true });
          const mesh = new THREE.Mesh(geometry, meshMaterial);
          scene.add(mesh);
          */
        },
        (xhr) => {
          console.log(`${(xhr.loaded / xhr.total) * 100}% loaded`);
        },
        (error) => {
          console.error("Error loading PLY file:", error);
        }
      );

      // 창 크기 변경 시 처리
      window.addEventListener("resize", onWindowResize, false);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update(); // OrbitControls 매 프레임 업데이트
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>


